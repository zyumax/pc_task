## データベース設計のアンチパターンを学ぶ9

### 課題1-1
MySQLやPostgreSQLには「Check」「Enum」「Domain」「Trigger」など、システムの仕様をデータベースに強制するために様々な機能が用意されています。

以下のケースを読みながら、どのような状況で上記機能を使うべきか、どのような状況で使うべきではないか、考えてみてください！

本サービスには「User」というテーブルが用意されていると仮定します
上記の設計だとどのような問題が生じるか、説明してください。

- 「mailAddress」カラムには、特定のドメインを持ったメールアドレスしか登録できない（a@example.com, b@example.comなど）。Checkを使うべきでしょうか？
  - 使用すべきでない。仕様変更があった際に、テーブルの変更が必要。アプリケーション側でバリデーションをかける方が、仕様変更に柔軟に対応できると思う。ただ、仕様変更がないのであれば、使ってもいいと思う。

- ユーザーが退会した時、当該ユーザーのレコードを「User」テーブルから削除し、同じ情報を「WithdrawnUser」テーブルに挿入しなければいけない。Triggerを使うべきでしょうか？
  - 使用すべきでない。エラーメッセージから原因が特定しにくい。また、DBMSで処理しているため、保守がしにくいと思う。(ドキュメントなどに残しておかないと、引き継いだ人がわからなくなりそう)

- 「gender」カラムには「male」「female」「no response」いずれかの値しか入れてはいけない。Enumを使うべきでしょうか？
  - 使用すべきでない。仕様変更があった際に、テーブルの変更が必要。「右、左」のように絶対に変わらない値なら使ってもよいと思う。

- 「postCode」カラムには特定形式の文字列しか入れてはいけない。Domainを使うべきでしょうか？
  - 使用してもいいと思う。郵便番号は形式が決まっているので、Domainで制約をかけても問題ないと思う。ただ、アプリケーション側でもバリデーションをかけられるので、アプリ側のバリデーションを優先してよいかなと思う。アプリ経由でエラーメッセージなどを表示できるので。より強い制限をDBにかけたい場合は、使用するイメージ。


上記のような制約をアプリケーション側で課すアプローチと、データベース側で制約を課すアプローチがあります。どちらをどのような時に採用するべきだと思いますか？
主キー、外部キー、NOT NULL制約などの持続性の高い制約はデータベース側で実装
それ以外のビジネスロジックはアプリケーション側で実装する。